class PasswordTolerance{constructor(passphrase,normalizers){this.passphrase=passphrase;this.actualNormalizers=this.buildNormalizers(normalizers)}normalize(){for(let normalizer of this.actualNormalizers){this.passphrase=normalizer.normalize(this.passphrase)}return this.passphrase}buildNormalizers(normalizers){let res=[];if(normalizers.lowerCase)res.push(new LowerCaseNormalize);if(normalizers.trim)res.push(new TrimNormalize);if(normalizers.whitespacesToDash)res.push(new WhitespacesToDashNormalize);if(normalizers.digitsToSingleZero)res.push(new DigitsToSingleZeroNormalize);if(normalizers.removePunctuation)res.push(new RemovePunctuationNormalize);return res}}class LowerCaseNormalize{normalize(passphrase){return passphrase.toLowerCase()}}class TrimNormalize{normalize(passphrase){return passphrase.trim()}}class WhitespacesToDashNormalize{normalize(passphrase){return passphrase.replace(/\s+/g,"-")}}class DigitsToSingleZeroNormalize{normalize(passphrase){return passphrase.replace(/\d+/g,"0")}}class RemovePunctuationNormalize{normalize(passphrase){return passphrase.replace(/[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~]/g,"")}}exports.PasswordTolerance=PasswordTolerance;const loginConstraints={hashcash:{presence:false},"hashcash.require":{presence:function(value,attribute){return attribute&&attribute.hashcash},type:"boolean"},"hashcash.zeroCount":{presence:function(value,attribute){return attribute&&attribute.hashcash&&attribute.hashcash.require},numericality:{onlyInteger:true,greaterThan:0,lessThanOrEqualTo:10}},"hashcash.serverString":{presence:function(value,attribute){return attribute&&attribute.hashcash&&attribute.hashcash.require}},csrfToken:{presence:false},"csrfToken.require":{presence:function(value,attribute){return attribute&&attribute.csrfToken},type:"boolean"}};const passwordToleranConstraints={normalizers:{presence:false},"normalizers.lowerCase":{presence:false,type:"boolean"},"normalizers.trim":{presence:false,type:"boolean"},"normalizers.whitespacesToDash":{presence:false,type:"boolean"},"normalizers.digitsToSingleZero":{presence:false,type:"boolean"},"normalizers.removePunctuation":{presence:false,type:"boolean"},passphraseMinimalLength:{presence:true,numericality:{onlyInteger:true,greaterThanOrEqualTo:20}}};exports.loginConstraints=loginConstraints;exports.passwordToleranConstraints=passwordToleranConstraints;const validate=require("validate.js");const{PasswordTolerance:PasswordToleranceRef}=require("./passwordTolerance");const{loginFetch:loginFetch,generateHashCash:generateHashCash}=require("./utils");const{loginConstraints:loginConstraints,passwordToleranConstraints:passwordToleranConstraints}=require("./serverInstructions");class Signum{static async executeLogin(username,hashedPasstext,loginUrl,serverInstructions,referer,state,csrfToken="",loginFunction=loginFetch){if(!username){throw new Error("Username is null or empty")}if(!hashedPasstext){throw new Error("Passtext is null or empty")}if(!loginUrl){throw new Error("loginUrl is null or empty")}const invalidLoginUrl=validate.single(loginUrl,{url:{allowLocal:true}});if(invalidLoginUrl){throw new Error(`Bad loginUrl: ${loginUrl} ${JSON.stringify(invalidLoginUrl)}`)}if(!serverInstructions){throw new Error("serverInstructions is null or empty")}if(!referer){throw new Error("referer is null or empty")}if(!state){throw new Error("state is null or empty")}const invalidServerInstructions=validate(serverInstructions,loginConstraints,{format:"flat"});if(invalidServerInstructions){throw new Error(`Bad serverInstructions: ${JSON.stringify(invalidServerInstructions)}`)}const headers={"Content-Type":"application/json;charset=utf-8","X-Username":username,"X-hashed-Passtext":hashedPasstext};if(serverInstructions.hashcash&&serverInstructions.hashcash.require){headers["X-Hashcash"]=await generateHashCash(serverInstructions.hashcash.zeroCount,serverInstructions.hashcash.serverString)}if(serverInstructions.csrfToken&&serverInstructions.csrfToken.require){if(!csrfToken){throw new Error("csrfToken is null or empty")}headers["X-Csrf-Token"]=csrfToken}return await loginFunction(loginUrl,{method:"POST",headers:headers,body:state,referrer:referer})}static normalizePassphrase(passphrase,serverInstructions){if(!passphrase){throw new Error("Passphrase is null or empty")}if(!serverInstructions){throw new Error("serverInstructions is null or empty")}const invalidServerInstructions=validate(serverInstructions,passwordToleranConstraints,{format:"flat"});if(invalidServerInstructions){throw new Error(`Bad serverInstructions: ${JSON.stringify(invalidServerInstructions)}`)}if(serverInstructions.normalizers&&passphrase.length>=serverInstructions.passphraseMinimalLength){passphrase=new PasswordToleranceRef(passphrase,serverInstructions.normalizers).normalize()}return passphrase}}exports.Signum=Signum;const fetch=require("cross-fetch");const crypto=require("crypto");const dateFormat=require("dateformat");const hexToBinary=require("hex-to-binary");async function getPublicIp(){return new Promise((resolve,reject)=>{fetch("https://api.ipify.org").then(response=>{if(response.ok){resolve(response.text())}else{reject("Failed to fetch ip address")}})})}async function loginFetch(loginUrl,details){return new Promise((resolve,reject)=>{fetch(loginUrl,details).then(response=>{if(response.ok){resolve(response.json())}else{reject("Failed to fetch login")}})})}function btoa(input){return Buffer.from(input).toString("base64")}async function generateHashCash(zeroCount,serverString){const ipAddress=await getPublicIp();const timestamp=dateFormat(new Date,"yyyymmdd-HHMMss");let header="";let found=false;let binaryHash;while(!found){const randomString=btoa((Math.floor(Math.random()*Number.MAX_VALUE)+1).toString());let counter=0;while(counter<Number.MAX_VALUE-1){header=`${zeroCount}:${timestamp}:${ipAddress}:${serverString}:${randomString}:${btoa(counter.toString())}`;const hexHash=crypto.createHash("sha1").update(header).digest("hex").toString();binaryHash=hexToBinary(hexHash);if(binaryHash.startsWith("0".repeat(zeroCount))){found=true;break}counter++}}console.log(`Generated header: ${header}`);console.log(`Corresponding hash: ${binaryHash}`);return header}exports.generateHashCash=generateHashCash;exports.getPublicIp=getPublicIp;exports.loginFetch=loginFetch;
//# sourceMappingURL=signum.min.js.map